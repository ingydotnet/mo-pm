=encoding utf8

=head1 Name

Mo::isa - Adds the isa feature to Mo's has

=head1 Synopsis

    use Mo qw'isa';
    has name => ( isa => 'Str' );

=head1 Description

Adds the isa parameter to has.

Clearly this does not support the full Moose type constraint system, but it
does support:

=over

=item * Moose's built-in non-parameterized type constraints

ClassName and RoleName constraints are not verified to the same extent
that Moose does. Any non-empty string containing no whitespace passes.

=item * Any type constraint containing "::" (which is treated as a class name).

Note:

  package Person;
  use Mo qw/isa/;
  has 'name' => (isa => 'Str');
  
  package Child;
  use Mo qw/isa/;
  extends 'Person';
  has 'father' => (isa => 'Person');    # ignored, no double-colon
  has 'mother' => (isa => '::Person');  # checks that value is a Person

=item * The C<< ScalarRef[`a] >>, C<< ArrayRef[`a] >> and C<< HashRef[`a] >> constraints are supported, but the parameter is ignored.

=item * The C<< Maybe[`a] >> constraint, provided that the parameter is supported.

=item * Unions like "Str|Int" are supported.

For parameterized types (such as ArrayRef, Maybe, etc), unioned
parameters are likely to confuse Mo::isa's very naive parsing of
'isa'. Don't expect this to work:

  ArrayRef[Str|::DateTime]

=back

Additionally, Moo-style type constraints are supported, a la:

  has age => (isa => sub { die "must be non-negative" if $_[0] < 0 });

Any unrecognised type is given an automatic "pass".

=head2 C<< Mo::isa::check($type, $value) >>

A convenience function is provided for checking a value against a type
constraint. Returns a boolean, even in list context.

=head2 C<< %Mo::isa::TC >>

This is a hash mapping allowing additional type constraints to be defined.
The key is the name of the type constraint; the value is a coderef that
should return true iff C<< $_ >> meets the constraint.

=cut
