package Mo::isa;$M="Mo::";
$VERSION=0.30;
sub O{UNIVERSAL::can(@_,'isa')}sub Z{1}sub R(){ref}sub Y(){defined&&!ref}sub L(){Y&&/^([+-]?\d+|([+-]?)(?=\d|\.\d)\d*(\.\d*)?(e([+-]?\d+))?|(Inf(inity)?|NaN))$/i}our%TC=(Any,\&Z,Item,\&Z,Bool,\&Z,Undef,sub{!defined},Defined,sub{defined},Value,\&Y,Str,\&Y,Num,\&L,Int,sub{L&&int($_)==$_},Ref,\&R,FileHandle,\&R,Object,sub{R&&O($_)},(map{$_.'Name',sub{Y&&/^\S+$/}}qw/Class Role/),map{my$J=/R/ ?$_:uc$_;"${_}Ref",sub{R eq$J}}qw/Scalar Array Hash Code Glob Regexp/,);sub check{my$v=pop;if(ref$_[0]eq'CODE'){return eval{$_[0]->($v);1 }}@_=split/\|/,shift;while(@_){(my$t=shift)=~s/(^\s+)|(\s+$)//g;if($t=~/^Maybe\[(.+)\]$/){unshift@_,'Undef',$1;next}$t=$1 if$t=~/^(.+)\[/;if(my$chk=$TC{$t}){local$_=$v;return 1 if$chk->()}elsif($t=~/::/){return 1 if O($v)&&$v->isa($t)}else{return 1 }}return}sub av{my$t=shift;ref($t)eq'CODE'?$t->(@_):do{die"not $t\n"if!check($t,@_)}}my%cx;*{$M.'isa::e'}=sub{my($P,$e,$o)=@_;{my$C=*{$P."new"}{CODE}||*{$M.Object::new}{CODE};*{$P."new"}=sub{my%a=@_[1..$#_];for my$arg(keys%a){av($cx{$P.$arg},$a{$arg})if$cx{$P.$arg}}$C->(@_)}}$o->{isa}=sub{my($m,$n,%a)=@_;my$V=$cx{$P.$n}=$a{isa}or return$m;sub{av($V,$_[1])if$#_;$m->(@_)}}};
