package Mo::isa;$M="Mo::";
$VERSION=0.30;
sub O{UNIVERSAL::can(@_,'isa')}sub Z{1}sub R(){ref}sub Y(){defined&&!ref}sub L(){Y&&/^([+-]?\d+|([+-]?)(?=\d|\.\d)\d*(\.\d*)?(e([+-]?\d+))?|(Inf(inity)?|NaN))$/i}our%TC=(Any,\&Z,Item,\&Z,Bool,sub{my$t=$_;!defined($t)or grep{"$_"eq$t}'',0,1},Undef,sub{!defined},Defined,sub{defined},Value,\&Y,Str,\&Y,Num,\&L,Int,sub{L&&int($_)==$_},Ref,\&R,FileHandle,\&R,Object,sub{R&&O($_)},(map{$_.Name,sub{Y&&/^\S+$/}}qw/Class Role/),map{my$J=/R/?$_:uc$_;"${_}Ref",sub{R eq$J}}qw/Scalar Array Hash Code Glob Regexp/,);sub check{my$v=pop;if(ref$_[0]eq'CODE'){return eval{$_[0]->($v);1}}@_=split/\|/,shift;while(@_){(my$t=shift)=~s/(^\s+)|(\s+$)//g;if($t=~/^Maybe\[(.+)\]$/){unshift@_,'Undef',$1;next}$t=$1 if$t=~/^(.+)\[/;if(my$k=$TC{$t}){local$_=$v;return 1 if$k->()}elsif($t=~/::/){return 1 if O($v)&&$v->isa($t)}else{return 1}}0}sub av{my$t=shift;ref($t)eq'CODE'?$t->(@_):do{die"not $t\n"if!check($t,@_)}}my%cx;*{$M.isa::e}=sub{my($P,$e,$o)=@_;my$C=*{$P.new}{CODE}||*{$M.Object::new}{CODE};*{$P.new}=sub{my%a=@_[1..$#_];for(keys%a){av$cx{$P.$_},$a{$_}if$cx{$P.$_}}goto$C};$o->{isa}=sub{my($m,$n,%a)=@_;my$V=$cx{$P.$n}=$a{isa}or return$m;sub{av$V,$_[1]if$#_;$m->(@_)}}}
